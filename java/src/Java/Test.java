package Java;

//결론 : 업캐스팅을 하는 이유는 다형성의 특징 때문이다.

/* 	class 해장국 {				//부모클래스
 *		간맞추기() 메소드 {
 *			//출력: "소금치기"
 *		}
 *  }
 */
class 해장국{
	public void 간맞추기(){
		System.out.println("소금치기");
	}
}


class 뼈다귀해장국 extends 해장국{
	@Override
	public void 간맞추기(){
		System.out.println("뼈다귀해장국에는 들깨가루 넣기");
	}

	public void 뼈추가하기(){
		System.out.println("뼈 추가!");
	}
}

class 콩나물해장국 extends 해장국{

	@Override
	public void 간맞추기() {
		System.out.println("콩나물해장국에는 고춧가루 넣기");
	}
	
	public void 콩나물넣기(){
		System.out.println("콩나물 추가!");
	}
}

//class 취객
class 취객{
	
	//업캐스팅 후 부모클래스 타입의 참조변수로 여러 자식 객체를 받을때
	//하나의 메소드만 만들되, 매개변수의 타입을 업캐스팅의 개념으로 받는게 더 효율적이다.
	public void 해장국간맞추기(해장국 해장국종류){
		해장국종류.간맞추기();
	}
	
	
	/* 매개변수에 맞는 타입의 메소드를 만들어줘야하기 때문에 비효율적임 */
	//매개변수로 전달받은 그 객체에 맞는 클래스타입의 참조변수로만 객체를 전달 받을 수 있다.
	public void 뼈다귀해장국간맞추기(뼈다귀해장국 뼈_해){
		뼈_해.간맞추기();
	}
	
	//매개변수로 전달받은 그 객체에 맞는 클래스타입의 참조변수로만 객체를 전달 받을 수 있다.	
	public void 콩나물해장국간맞추기(콩나물해장국 콩_해){
		콩_해.간맞추기();
	}
}

public class Test {

	public static void main(String[] args) {

		//취객 객체 생성 -> 참조변수 취객1
		취객 취객1 = new 취객();
		
		//방법1.(추천)
		//해장국 클래스타입 참조변수 - 뼈다귀해장국 객체 생성	->	업캐스팅
		//취객1이 주문한 해장국1 생성(참조변수이름->해장국1)
		//조상타입의 참조변수 = 자식객체 생성;
		해장국 해장국1;
		해장국1 = new 뼈다귀해장국();
		취객1.해장국간맞추기(해장국1);
		
		//조상타입의 참조변수 = 자식객체 생성;	//업캐스팅
		해장국1 = new 콩나물해장국();
		취객1.해장국간맞추기(해장국1);

		
		
		//방법2.(비추천)
		//자기자신 클래스타입의 참조변수로 자기자신 객체 생성
		뼈다귀해장국 뼈 = new 뼈다귀해장국();
		취객1.뼈다귀해장국간맞추기(뼈);
		
		콩나물해장국 콩 = new 콩나물해장국();
		취객1.콩나물해장국간맞추기(콩);
	}

}
